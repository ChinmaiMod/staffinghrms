"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildArgs = exports.GolangciLint = void 0;
const child_process_1 = require("child_process");
const util_1 = require("util");
const path_1 = require("path");
const execFileAsync = (0, util_1.promisify)(child_process_1.execFile);
class GolangciLint {
    async lint(filePaths, configPath) {
        const timestamp = new Date().toISOString();
        const args = (0, exports.buildArgs)(filePaths, configPath);
        try {
            // golangci-lint exits with non-zero code when issues are found
            await execFileAsync('golangci-lint', args);
            return createLintData(timestamp, filePaths, []);
        }
        catch (error) {
            if (!isExecError(error))
                throw error;
            const results = parseResults(error.stdout);
            return createLintData(timestamp, filePaths, results);
        }
    }
}
exports.GolangciLint = GolangciLint;
// Helper functions
const buildArgs = (filePaths, configPath) => {
    const args = ['run', '--output.json.path=stdout', '--path-mode=abs'];
    if (configPath) {
        args.push('--config', configPath);
    }
    else {
        args.push('--no-config');
    }
    // Convert file paths to unique directories since golangci-lint runs on directories
    const directories = [...new Set(filePaths.map((file) => (0, path_1.dirname)(file)))];
    args.push(...directories);
    return args;
};
exports.buildArgs = buildArgs;
const isExecError = (error) => error !== null && typeof error === 'object' && 'stdout' in error;
// Parse golangci-lint JSON output - only first line contains JSON, rest is summary
const parseResults = (stdout) => {
    try {
        if (stdout === undefined || stdout === '') {
            return [];
        }
        const lines = stdout.split('\n');
        const jsonLine = lines[0];
        if (jsonLine.trim() === '') {
            return [];
        }
        const parsed = JSON.parse(jsonLine);
        return parsed.Issues ?? [];
    }
    catch {
        return [];
    }
};
const createLintData = (timestamp, files, results) => {
    const issues = results.flatMap(toIssue);
    return {
        timestamp,
        files,
        issues,
        errorCount: countBySeverity(issues, 'error'),
        warningCount: countBySeverity(issues, 'warning'),
    };
};
const toIssue = (issue) => {
    // Check if this contains multiple issues in the Text field
    if (issue.Text.includes('\n') && issue.Text.includes('.go:')) {
        // Parse multi-line text to extract individual issues
        const lines = issue.Text.split('\n').slice(1); // Skip module name line
        return lines
            .filter((line) => line.includes('.go:'))
            .map((line) => parseIssueLine(line, issue.FromLinter))
            .filter((parsedIssue) => parsedIssue !== null);
    }
    // Single issue
    return [
        {
            file: issue.Pos.Filename,
            line: issue.Pos.Line,
            column: issue.Pos.Column,
            severity: 'error',
            message: issue.Text,
            rule: issue.FromLinter,
        },
    ];
};
const parseIssueLine = (line, linter) => {
    // Parse format: "./file-with-issues.go:8:2: declared and not used: message"
    const parts = line.split(':');
    const MIN_PARTS = 4; // filename:line:column:message
    if (parts.length < MIN_PARTS || !line.includes('.go:'))
        return null;
    const filename = parts[0];
    const lineStr = parts[1];
    const columnStr = parts[2];
    const MESSAGE_START_INDEX = 3;
    const message = parts.slice(MESSAGE_START_INDEX).join(':').trim();
    if (!filename.endsWith('.go') ||
        !/^\d+$/.test(lineStr) ||
        !/^\d+$/.test(columnStr)) {
        return null;
    }
    return {
        file: filename,
        line: parseInt(lineStr, 10),
        column: parseInt(columnStr, 10),
        severity: 'error',
        message,
        rule: linter,
    };
};
const countBySeverity = (issues, severity) => issues.filter((i) => i.severity === severity).length;
