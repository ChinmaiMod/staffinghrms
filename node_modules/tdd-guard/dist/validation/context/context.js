"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDynamicContext = generateDynamicContext;
const Config_1 = require("../../config/Config");
const toolSchemas_1 = require("../../contracts/schemas/toolSchemas");
const processors_1 = require("../../processors");
const lintProcessor_1 = require("../../processors/lintProcessor");
// Import core prompts
const system_prompt_1 = require("../prompts/system-prompt");
const rules_1 = require("../prompts/rules");
const file_types_1 = require("../prompts/file-types");
const response_1 = require("../prompts/response");
// Import operation-specific context
const edit_1 = require("../prompts/operations/edit");
const multi_edit_1 = require("../prompts/operations/multi-edit");
const write_1 = require("../prompts/operations/write");
const todos_1 = require("../prompts/tools/todos");
const test_output_1 = require("../prompts/tools/test-output");
const lint_results_1 = require("../prompts/tools/lint-results");
function generateDynamicContext(context, config) {
    const operation = JSON.parse(context.modifications);
    const effectiveConfig = config ?? new Config_1.Config();
    const sections = [
        // 1. Core sections (system prompt only for CLI)
        getSystemPrompt(effectiveConfig),
        context.instructions ?? rules_1.RULES,
        file_types_1.FILE_TYPES,
        // 2. Operation-specific context and changes
        formatOperation(operation),
        // 3. Additional context
        formatTestSection(context.test),
        formatTodoSection(context.todo),
        formatLintSection(context.lint),
        // 4. Response format
        response_1.RESPONSE,
    ];
    return sections.filter(Boolean).join('\n');
}
function formatOperation(operation) {
    if ((0, toolSchemas_1.isEditOperation)(operation)) {
        return edit_1.EDIT + formatEditOperation(operation);
    }
    if ((0, toolSchemas_1.isMultiEditOperation)(operation)) {
        return multi_edit_1.MULTI_EDIT + formatMultiEditOperation(operation);
    }
    if ((0, toolSchemas_1.isWriteOperation)(operation)) {
        return write_1.WRITE + formatWriteOperation(operation);
    }
    return '';
}
function formatEditOperation(operation) {
    return (formatSection('File Path', operation.tool_input.file_path) +
        formatSection('Old Content', operation.tool_input.old_string) +
        formatSection('New Content', operation.tool_input.new_string));
}
function formatMultiEditOperation(operation) {
    const editsFormatted = operation.tool_input.edits
        .map((edit, index) => formatEdit(edit, index + 1))
        .join('');
    return `${formatSection('File Path', operation.tool_input.file_path)}\n### Edits\n${editsFormatted}`;
}
function formatWriteOperation(operation) {
    return (formatSection('File Path', operation.tool_input.file_path) +
        formatSection('New File Content', operation.tool_input.content));
}
function formatEdit(edit, index) {
    return (`\n#### Edit ${index}:\n` +
        `**Old Content:**\n${codeBlock(edit.old_string)}` +
        `**New Content:**\n${codeBlock(edit.new_string)}`);
}
function formatTestSection(testOutput) {
    if (!testOutput)
        return '';
    const output = testOutput.trim()
        ? new processors_1.TestResultsProcessor().process(testOutput)
        : 'No test output available. Tests must be run before implementing.';
    return test_output_1.TEST_OUTPUT + codeBlock(output);
}
function formatTodoSection(todoJson) {
    if (!todoJson)
        return '';
    const todoOperation = JSON.parse(todoJson);
    const todos = todoOperation.tool_input?.todos ?? [];
    const todoItems = todos
        .map((todo, index) => `${index + 1}. [${todo.status}] ${todo.content} (${todo.priority})`)
        .join('\n');
    return `${todos_1.TODOS}${todoItems}\n`;
}
function formatLintSection(lintData) {
    if (!lintData)
        return '';
    const formattedLintData = (0, lintProcessor_1.formatLintDataForContext)(lintData);
    return lint_results_1.LINT_RESULTS + codeBlock(formattedLintData);
}
function formatSection(title, content) {
    return `\n### ${title}\n${codeBlock(content)}`;
}
function codeBlock(content) {
    return `\`\`\`\n${content}\n\`\`\`\n`;
}
function getSystemPrompt(config) {
    // Only the CLI client requires the system prompt in the query
    return config.validationClient === 'cli' ? system_prompt_1.SYSTEM_PROMPT : '';
}
