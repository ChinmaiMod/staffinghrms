"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFileModification = exports.isTodoWriteOperation = exports.isWriteOperation = exports.isMultiEditOperation = exports.isEditOperation = exports.FileModificationSchema = exports.ToolOperationSchema = exports.TodoWriteOperationSchema = exports.WriteOperationSchema = exports.MultiEditOperationSchema = exports.EditOperationSchema = exports.TodoWriteSchema = exports.WriteSchema = exports.MultiEditSchema = exports.EditSchema = exports.TodoSchema = exports.SessionStartSchema = exports.UserPromptSubmitSchema = exports.HookDataSchema = exports.HookContextSchema = void 0;
const zod_1 = require("zod");
// Base Hook Context
exports.HookContextSchema = zod_1.z.object({
    session_id: zod_1.z.string(),
    transcript_path: zod_1.z.string(),
    hook_event_name: zod_1.z.string(),
});
exports.HookDataSchema = exports.HookContextSchema.extend({
    tool_name: zod_1.z.string(),
    tool_input: zod_1.z.unknown(),
});
// UserPromptSubmit Schema
exports.UserPromptSubmitSchema = exports.HookContextSchema.extend({
    prompt: zod_1.z.string(),
    cwd: zod_1.z.string(),
}).refine((data) => data.hook_event_name === 'UserPromptSubmit');
// SessionStart Schema
exports.SessionStartSchema = exports.HookContextSchema.extend({
    hook_event_name: zod_1.z.literal('SessionStart'),
    source: zod_1.z.enum(['startup', 'resume', 'clear']),
});
// Tool Input Schemas
exports.TodoSchema = zod_1.z.object({
    content: zod_1.z.string(),
    status: zod_1.z.enum(['pending', 'in_progress', 'completed']),
    priority: zod_1.z.enum(['high', 'medium', 'low']),
    id: zod_1.z.string(),
});
exports.EditSchema = zod_1.z.object({
    file_path: zod_1.z.string(),
    old_string: zod_1.z.string(),
    new_string: zod_1.z.string(),
    replace_all: zod_1.z.boolean().optional(),
});
const EditEntrySchema = zod_1.z.object({
    old_string: zod_1.z.string(),
    new_string: zod_1.z.string(),
    replace_all: zod_1.z.boolean().optional(),
});
exports.MultiEditSchema = zod_1.z.object({
    file_path: zod_1.z.string(),
    edits: zod_1.z.array(EditEntrySchema).min(1),
});
exports.WriteSchema = zod_1.z.object({
    file_path: zod_1.z.string(),
    content: zod_1.z.string(),
});
exports.TodoWriteSchema = zod_1.z.object({
    todos: zod_1.z.array(exports.TodoSchema).min(1),
});
// Tool Operation Schemas
exports.EditOperationSchema = exports.HookContextSchema.extend({
    tool_name: zod_1.z.literal('Edit'),
    tool_input: exports.EditSchema,
});
exports.MultiEditOperationSchema = exports.HookContextSchema.extend({
    tool_name: zod_1.z.literal('MultiEdit'),
    tool_input: exports.MultiEditSchema,
});
exports.WriteOperationSchema = exports.HookContextSchema.extend({
    tool_name: zod_1.z.literal('Write'),
    tool_input: exports.WriteSchema,
});
exports.TodoWriteOperationSchema = exports.HookContextSchema.extend({
    tool_name: zod_1.z.literal('TodoWrite'),
    tool_input: exports.TodoWriteSchema,
});
// Discriminated Unions
exports.ToolOperationSchema = zod_1.z.discriminatedUnion('tool_name', [
    exports.EditOperationSchema,
    exports.MultiEditOperationSchema,
    exports.WriteOperationSchema,
    exports.TodoWriteOperationSchema,
]);
exports.FileModificationSchema = zod_1.z.discriminatedUnion('tool_name', [
    exports.EditOperationSchema,
    exports.MultiEditOperationSchema,
    exports.WriteOperationSchema,
]);
// Type Guards
const isEditOperation = (op) => op.tool_name === 'Edit';
exports.isEditOperation = isEditOperation;
const isMultiEditOperation = (op) => op.tool_name === 'MultiEdit';
exports.isMultiEditOperation = isMultiEditOperation;
const isWriteOperation = (op) => op.tool_name === 'Write';
exports.isWriteOperation = isWriteOperation;
const isTodoWriteOperation = (op) => op.tool_name === 'TodoWrite';
exports.isTodoWriteOperation = isTodoWriteOperation;
const isFileModification = (op) => op.tool_name === 'Edit' ||
    op.tool_name === 'MultiEdit' ||
    op.tool_name === 'Write';
exports.isFileModification = isFileModification;
